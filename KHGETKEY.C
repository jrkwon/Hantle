/*
 *  파일   : khgetkey.c
 *  내용   : 2, 3 벌식 한글입력 저수준 함수들
 *  기획   : hantle.prj, nal.prj
 *  날짜   : 93.03.16
 *  만든이 : 한양대학교 전자통신공학과 한틀아리 권재락
 *  알림글 : 이 풀그림의 밑그림은 공개를 원칙으로 합니다.
 *           왜냐하면, 나도 다른 밑그림의 도움을 많이 받았으니까요.
 *           따라서, 이 밑그림을 받으신 분은 다른데 사용하셔도 되지만
 *           새로 만든 밑그림도 잘 정리하셔서 공개해 주시기 바랍니다.
 */

#include <bios.h>
#include <ctype.h>

#include "hkeydef.h"

#define TRUE  1
#define FALSE 0

enum { HANKBD2, HANKBD3 };

int HanKbdKind  = HANKBD2;             /* 현재의 한글 자판 종류    */
int HanKbdState = FALSE;               /* 현재의 한/영 상태       */

static int PushedKey = 0;              /* 한 문자짜리 내부 키 버퍼    */

/*
** 두벌식 한글 자판 배열 표
*/
static unsigned char HanKbdTable2[] = {
  0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27,  /*  !"#$%&' */
  0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0x2F,  /* ()*+,-./ */
  0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,  /* 01234567 */
  0x38, 0x39, 0x3A, 0x3B, 0x3C, 0x3D, 0x3E, 0x3F,  /* 89:;<=>? */
  0x40, 0x88, 0xBA, 0x90, 0x8D, 0x86, 0x87, 0x94,  /* @ABCDEFG */
  0xAD, 0xA5, 0xA7, 0xA3, 0xBD, 0xBB, 0xB4, 0xA6,  /* HIJKLMNO */
  0xAC, 0x8A, 0x83, 0x84, 0x8C, 0xAB, 0x93, 0x8F,  /* PQRSTUVW */
  0x92, 0xB3, 0x91, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,  /* XYZ[\]^_ */
  0x60, 0x88, 0xBA, 0x90, 0x8D, 0x85, 0x87, 0x94,  /* `abcdefg */
  0xAD, 0xA5, 0xA7, 0xA3, 0xBD, 0xBB, 0xB4, 0xA4,  /* hijklmno */
  0xAA, 0x89, 0x82, 0x84, 0x8B, 0xAB, 0x93, 0x8E,  /* pqrstuvw */
  0x92, 0xB3, 0x91, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F   /* xyz{|}~  */
};
/*
** 세벌식 한글 자판 배열 표
*/
static unsigned char HanKbdTable3[] = {
  0x20, 0xD8, 0x22, 0x23, 0x24, 0x25, 0x26, 0x92,  /*  !"#$%&' */
  0x28, 0x29, 0x2A, 0x2B, 0x2C, 0x2D, 0x2E, 0xAD,  /* ()*+,-./ */
  0x91, 0xDD, 0xD6, 0xD3, 0xB3, 0xBA, 0xA5, 0xAC,  /* 01234567 */
  0xBC, 0xB4, 0x3A, 0x89, 0x32, 0x3D, 0x33, 0x3F,  /* 89:;<=>? */
  0x40, 0xC8, 0x21, 0xCB, 0xCA, 0xDA, 0xC3, 0x3B,  /* @ABCDEFG */
  0x27, 0x38, 0x34, 0x35, 0x36, 0x31, 0x30, 0x39,  /* HIJKLMNO */
  0x3E, 0xDC, 0xA6, 0xC7, 0x3A, 0x37, 0xD0, 0xDB,  /* PQRSTUVW */
  0xD4, 0x3C, 0xD9, 0x5B, 0x5C, 0x5D, 0x5E, 0x5F,  /* XYZ[\]^_ */
  0x60, 0xD7, 0xB4, 0xAA, 0xBD, 0xAB, 0xA3, 0xBB,  /* `abcdefg */
  0x84, 0x88, 0x8D, 0x82, 0x8E, 0x94, 0x8B, 0x90,  /* hijklmno */
  0x93, 0xD5, 0xA4, 0xC5, 0xA7, 0x85, 0xAD, 0xC9,  /* pqrstuvw */
  0xC2, 0x87, 0xD1, 0x7B, 0x7C, 0x7D, 0x7E, 0x7F   /* xyz{|}~  */
};

/*
** 입력된 키 값을 현재의 자판 상태에 따라 적절한 값으로 바꾸는 함수
*/
int ConvertKey(int key)
{
  char kstat = *((char far *) 0x00000417);
  unsigned char *HanKbdTable;

  if (key == ' ') {      /* <SHIFT-SPACE>등의 처리 */
    switch (kstat & 0xF) {
 /*   case 0x08:  key = ALT_SPACE;
        break;
      case 0x04:     key = CTRL_SPACE;
        break; */
      case 0x02:     key = LSHIFT_SPACE;
        break;
      case 0x01:     key = RSHIFT_SPACE;
        break;
     }
  }
  if (!HanKbdState || key <= 32 || key >= 127)
    return key;
  if ((kstat & 0x40) && isalpha(key))
    key = key ^ 0x20;
  HanKbdTable = (HanKbdKind == HANKBD2) ? HanKbdTable2 : HanKbdTable3;
  key = HanKbdTable[key-32] & 0xFF;
  return key;
}

/*
** 키보드에서 키가 눌릴 때까지 기다렸다가 그 키 코드를 돌려 주는 함수
*/
int GetKey(int inphan)
{
  int key;

  if (PushedKey) {
    key = PushedKey;
    PushedKey = 0;
  } else {
    key = bioskey(0);
    if(key & 0xFF)
    key &= 0xFF;
    if (inphan) key = ConvertKey(key);
  }
  return key;
}

/*
** 한 문자짜리 내부 키 버퍼에 키를 하나 넣는 함수
*/
void PutKey(int key)
{
  PushedKey = key;
}

/*
** 키보드가 눌렸는지 검사하는 함수
*/
int InKeyBuf(void)
{
  return PushedKey ? PushedKey : bioskey(1);
}

/*
 *  khgetkety.c
 */